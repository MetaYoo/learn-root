# 高并发限流
高并发系统保护的三把利器：缓存、降级和限流
https://www.iteye.com/blog/jinnianshilongnian-2305117


## 缓存
> 缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹。
## 降级
> 降级是当服务出问题或者影响到核心流程额性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开

## 限流
> 有些场景并不能用缓存和降级来结局，比如稀缺资源（秒杀，抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页）、因此需要有一种手段来限制这些场景的并发/请求量，即限流


```text
一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。
先有缓存这个银弹，后有限流来应对618、双十一高并发流量，在处理高并发问题上可以说是如虎添翼，不用担心瞬间流量导致系统挂掉或雪崩，最终做到有损服务而不是不服务；限流需要评估好，不可乱用，否则会正常流量出现一些奇怪的问题而导致用户抱怨。

```

## 限流算法
> 常见的限流算法有：令牌桶、漏桶。计数器也可以进行粗暴限流实现。

### 令牌桶算法
> 令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：
  假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；
  桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；
  当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；
  如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。
  
  
### 漏桶算法
> 漏桶作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing），漏桶算法的描述如下：
一个固定容量的漏桶，按照常量固定速率流出水滴；
如果桶是空的，则不需流出水滴；
可以以任意速率流入水滴到漏桶；
如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。
>

###  令牌桶和漏桶对比
> 令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；
  漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；
  令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；
  漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；
  令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；
  两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。

### 计数器
> 另外有时候我们还使用计数器来进行限流，主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；只要全局总请求数或者一定时间段的总请求数设定的阀值则进行限流，是简单粗暴的总数量限流，而不是平均速率限流。



### 平滑限流某个接口的请求数

> 之前的限流方式都不能很好地应对突发请求，即瞬间请求可能都被允许从而导致一些问题；因此在一些场景中需要对突发请求进行整形，整形为平均速率请求处理（比如5r/s，则每隔200毫秒处理一个请求，平滑了速率）。这个时候有两种算法满足我们的场景：令牌桶和漏桶算法。Guava框架提供了令牌桶算法实现，可直接拿来使用。
Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。
