# SnowFlake雪花算法


## 为什么需要分布式全局唯一ID以及分布式ID的业务需求

ID生成规则部分硬性要求
 - 全局唯一
 - 趋势递增
 - 单调递增
 - 信息安全
 - 含时间戳
 
ID生成规则部分软性要求
- 高可用：发一个获取分布式ID的请求，服务器就要保证5个9甚至更高的情况下给我创建一个分布式ID
- 低延迟：发一个获取分布式ID的请求，服务器就要快，极速
- 高QPS：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶住且一下子成功创建10万个ID


## 为什么无序的UUID会导致入库性能变差呢
> 1. 无序，无法预测他的生成顺序，不能生成递增有序的数字。
  首先分布式ID一般都会作为主键，但是安装MySQL官方推荐主键要尽量越短越好，UUID每一个都很长，所以不是很推荐。
> 2. 主键，ID作为主键时在特定的环境会存在一些问题。
  比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的建议主键要尽量越短越好36个字符长度的UUID不符合要求
> 3. 索引，B+树索引的分裂
  既然分布式ID是主键，然后主键是包含索引的，然后MySQL的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无需的，所以每一次UUID数据的插入都会对主键
  的B+树进行很大的修改，这一点很不好。无序不但会导致一些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能
  
>
## mysql
> CREATE TABLE t_test(
   id BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
   stub CHAR(1) NOT NULL DEFAULT '',
   UNIQUE KEY stub(stub)
)

> REPLACE INTO t_test(sub) VALUES('b'');
  SELECT LAST_INSERT_ID();

## 数据库自增ID机制适合作分布式ID吗？答案是不太适合
> 1: 系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4（步长是1），这个时候需要扩容机器一台。可以这样做：把第二胎机器的初始值设置的比第一台超过很多，貌似还好，现在想想一下如果我们线上有100台机器，这个时候要扩容该怎么做？
  简直是噩梦，所以系统水平扩展方案复杂难以实现。
> 2：数据库压力还是很大，每次获取ID都得读写一次数据库，非常影响性能，步服务分布式ID里面的延迟低和高QPS的规则（在高并发下，如果都去数据库里面获取ID，那是非常影响性能的）


## SnowFlake 雪花算法
> 优点： 
     毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
     不依赖数据等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的
     可以根据自身业务特性分配bit位，非常灵活
> 缺点：
     依赖机器始终，，如果机器时钟回拨，会导致重复ID生成
     在淡季上是递增的，但是由于涉及到分布式环境，每台机器上的始终不可能完全同步，有时候会出现不是全局递增的情况
     （此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）
