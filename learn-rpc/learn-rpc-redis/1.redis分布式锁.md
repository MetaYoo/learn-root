第一种：使用redis的setnx()、expire()方法，用于分布式锁
 - setnx(lockkey, 1) 如果返回0，则说明占位失败；如果返回1，则说明占位成功
 - expire()命令对lockkey设置超时时间，为的是避免死锁问题。
 - 执行完业务代码后，可以通过delete命令删除key。
```
这个方案其实是可以解决日常工作中的需求的，
但从技术方案的探讨上来说，可能还有一些可以完善的地方。
比如，如果在第一步setnx执行成功后，在expire()命令执行成功前，
发生了宕机的现象，那么就依然会出现死锁的问题
```


第二种：使用redis的setnx()、get()、getset()方法，用于分布式锁，解决死锁问题


1. setnx(lockkey, 当前时间+过期超时时间) ，如果返回1，则获取锁成功；如果返回0则没有获取到锁，转向2。
2. get(lockkey)获取值oldExpireTime ，并将这个value值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向3。
3. 计算newExpireTime=当前时间+过期超时时间，然后getset(lockkey, newExpireTime) 会返回当前lockkey的值currentExpireTime。
4. 判断currentExpireTime与oldExpireTime 是否相等，如果相等，说明当前getset设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
5. 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行delete释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。

